'use strict'
/*
function showMessage() {
	alert('Всем привет ');
}

function имя(параметры){
	...тело...
}

Наша новая функция может быть вызвана по её имени: showMessage().

function showMessage(){
	alert('всем привет!');
}

showMessage();
showMessage();

Вызов showMessage() выполняет код функции. Здесь мы увидим сообщение дважды.

Этот пример явно демонстрирует одно из главных предназначений функций: 
избавление от дублирования кода.

Локальные переменные

function showmessage() {
	let message = "Привет" ;
	alert(message);
}

showmessage(); // покажет сообщение(выполнит функцию)
alert(message) // Будет ошибкой, т.к. переменная в функции

Внешние переменные

let userName = "Максим";
function showMessage() {
	let message = 'Привет ' + userName;
	alert(message);
}
showMessage();

Функция обладает полным доступом к внешним переменным и 
может изменять их значение.

let userName = "Максим";
function showMessage() {
	userName = "Reni101";
let message = 'Привет ' + userName;
	alert(message);
}

alert (userName); // Максим
showMessage(); // выполнится присвоение Reni101 alert(message); Привет Reni101 
alert (userName);// alert присвоенное Reni101

						Параметры
Мы можем передать внутрь функции любую информацию, 
используя параметры (также называемые аргументами функции).
В нижеприведённом примере функции передаются два параметра: from и text.


function showMessage(from, text){
	alert(from + ": " + text); 
}
showMessage("Максим", 'привет');
showMessage("Максим", 'как дела?');



function showMessage(from, text) {
	from = '*' + from + '*';
	alert(from + ': ' + text);
}
let from = "Максим";
showMessage(from, "Привет");

alert(from)



function showMessage(from, text = "текст не добавлен") {
	alert(from + ": " + text);
} 
showMessage("Максим");

function showMessage(from, text = anotherFunction()) { //текст это запуск другйо функции
	// anotherFunction() выполнится только если не передан text
	 // результатом будет значение text
}
                      Возврат значения
Функция может вернуть результат, который будет передан в вызвавший её код.
Простейшим примером может служить функция сложения двух чисел:




function sum(a, b) {
	return a*b;
}
let result = sum(2, 5);
alert ( result);


Директива return может находиться в любом месте тела функции. Как только выполнение доходит до 
этого места, функция останавливается, и значение возвращается в вызвавший её код 
(присваивается переменной result выше).
Вызовов return может быть несколько, например:



function chekAge(age) {
	if ( age > 18) {
		return true;
	} else {
		return confirm("А родители разрешили?");
	}
}

let age = prompt('сколько вам лет?', 5);

if( chekAge(age) ) {
	alert ('Доступ получен');
} else {
	alert ( 'Доступ закрыт');
}

Возможно использовать return и без значения. Это приведёт к немедленному выходу из функции.

function showMovie(age) {
	if ( !checkAge(age)){
		return;
	}
	alert('Вам показывается кино');
}


//В коде выше, если checkAge(age) вернёт false, showMovie не выполнит alert.

Результат функции с пустым return или без него – undefined
Если функция не возвращает значения, это всё равно, как если бы она возвращала undefined:

function doNothing() {
	
}
alert(doNothing() === undefined); // true

Пустой return аналогичен return undefined:

function doNothing() {
	return;
}
alert(doNothing() === undefined); //true

Никогда не добавляйте перевод строки между return и его значением!!!

return // Js поставит ;
 (some + long + expression + or + whatever * f(a) + f(b))
 
 Таким образом, это фактически стало пустым return.
 
 return (
	some + Long + expession + or + whatever * f(a) + f(b)
 )
 
 тогда всё сработает
 

 Первый вариант использует метку nextPrime:
 
 function showPrimes(n) {
	 nextPrime: for (let i = 2; i < n; i++) {
		 for (let j = 2; j < i; j++){
			 if(i % j == 0) continue nextPrime;
		 }
		 alert(i)
	 }
	 
 }
 
 Второй вариант использует дополнительную функцию isPrime(n) для проверки на простое:
  
  
  function showPrimes(n) {
	  for(let i = 2; i< n; i++){
		  if (!isPrime(i)) continue;
		  
		  alert(i) //простое
	  }
  }
  
  function isPrime(n) {
	  for(let i = 2; i <n; i++){
		  if (n % i == 0) return false;
	  }
	  return true;
  }
  
  // я ничего не понял в двух примерах, выдимо придётся все перечитывать
  
Второй вариант легче для понимания, не правда ли? Вместо куска кода мы видим название действия 
(isPrime). Иногда разработчики называют такой код самодокументируемым.

Таким образом, допустимо создавать функции, даже если мы не планируем повторно использовать их. 
Такие функции структурируют код и делают его более понятным

										Итого
										
Объявление функции имеет вид:

function имя(параметры, через, запятую) {
   тело, код функции 
}

Передаваемые значения копируются в параметры функции и становятся локальными переменными.
Функции имеют доступ к внешним переменным. Но это работает только изнутри наружу. 
Код вне функции не имеет доступа к её локальным переменным.
Функция может возвращать значение. Если этого не происходит, тогда результат равен undefined.

Для того, чтобы сделать код более чистым и понятным, рекомендуется использовать локальные переменные и параметры функций, 
не пользоваться внешними переменными.

Функция, которая получает параметры, работает с ними и затем возвращает результат, 
гораздо понятнее функции, вызываемой без параметров, 
но изменяющей внешние переменные, что чревато побочными эффектами.

Именование функций:

Имя функции должно понятно и чётко отражать, что она делает. 
Увидев её вызов в коде, вы должны тут же понимать, что она делает, и что возвращает.
Функция – это действие, поэтому её имя обычно является глаголом.

Есть много общепринятых префиксов, таких как: create…, show…, get…, check… и т.д. 
Пользуйтесь ими как подсказками, поясняющими, что делает функция.

Функции являются основными строительными блоками скриптов. 
Мы рассмотрели лишь основы функций в JavaScript, но уже сейчас можем создавать и 
использовать их. Это только начало пути. Мы будем неоднократно возвращаться к 
функциям и изучать их всё более и более глубоко.




							homeWork


Обязателен ли "else"?
Следующая функция возвращает true, если параметр age больше 18.
В ином случае она запрашивает подтверждение через confirm и возвращает его результат:
 
function checkAge(age) {
	if(age > 18) {
		return true;
	} else {
		return confirm('Родители разрешили?');
	}
}
// да можно убрать


Перепишите функцию, используя оператор '?' или '||'
Следующая функция возвращает true, если параметр age больше 18.
В ином случае она задаёт вопрос confirm и возвращает его результат.

function checkAge(age){
	if(age > 18){
		return true;
	} else {
		return confirm("родители разрешили?");
	}
}



let age = prompt('Сколько вам лет', 18);
let result = age > 18 ? 'Здраствуй' :  "Родители разрешили?"
alert (result);



function checkAge(age){
	let result = age > 18 ? true : confirm "Родители разрешили?"
}

function checkAge(age) {
	return(age > 18) || confirm "Родители разрешили?"
}
// начал делать не через функцию

function min(a,b){
	if (a>b){
		return b
	} if (a<b){
		return a
	}
}
// подсмотрел if

Функция pow(x,n)
Напишите функцию pow(x,n), которая возвращает x в степени n. 
Иначе говоря, умножает x на себя n раз и возвращает результат.


*/
function pow(x, n) {
	return x**n
}
let result = pow(2, 4);
alert ( result);

// сделла сам испльзуя возвести в степень **

function pow(x, n) {
  let result = x;

  for (let i = 1; i < n; i++) {
    result *= x;
  }

  return result;
}

let x = prompt("Введите первое число", '');
let n = prompt("Введите второе число?", '');

if (n < 1) {
  alert(`Степень ${n} не поддерживается, используйте натуральное число`);
} else {
  alert( pow(x, n) );
}

// взял из учебника
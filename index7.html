<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<title>Занятие по JS 7</title>
</head>
<body>
	<h1>Циклы while и for</h1>	
	Для многократного повторения одного участка кода предусмотрены циклы.
	<h2>Цикл «while» </h2>
	Цикл while имеет следующий синтаксис:
	<!-- 
	while (condition) {
   код
   также называемый "телом цикла"
}
	-->
Код из тела цикла выполняется, пока условие condition истинно.

Например, цикл ниже выводит i, пока i < 3:

<!--let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}

Одно выполнение тела цикла по-научному называется итерация. Цикл в примере выше совершает три итерации.

Если бы строка i++ отсутствовала в примере выше, то цикл бы повторялся (в теории) вечно.
На практике, конечно, браузер не позволит такому случиться, он предоставит пользователю
возможность остановить «подвисший» скрипт, а JavaScript на стороне сервера придётся «убить» процесс.

Цикл «do…while»
do {
  // тело цикла
} while (condition);
Цикл сначала выполнит тело, а затем проверит условие condition,
и пока его значение равно true, он будет выполняться снова и снова.

let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);


Такая форма синтаксиса оправдана, если вы хотите, чтобы тело
цикла выполнилось хотя бы один раз, даже если условие окажется ложным. 
На практике чаще используется форма с предусловием: while(…) {…}.

Цикл «for»

for (начало; условие; шаг) {
  // ... тело цикла ...
}

Встроенное объявление переменной
В примере переменная счётчика i была объявлена прямо в цикле. Это так называемое «встроенное» объявление переменной. Такие переменные существуют только внутри цикла.

for (let i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // ошибка, нет такой переменной


Пропуск частей «for»
Любая часть for может быть пропущена.
Для примера, мы можем пропустить начало если нам ничего не нужно делать перед стартом цикла.
Вот так:
let i = 0; // мы уже имеем объявленную i с присвоенным значением
for (; i < 3; i++) { // нет необходимости в "начале"
  alert( i ); // 0, 1, 2
}
При этом сами точки с запятой ; обязательно должны присутствовать, 
иначе будет ошибка синтаксиса.
Прерывание цикла: «break»
Обычно цикл завершается при вычислении условия в false.
Но мы можем выйти из цикла в любой момент с помощью специальной директивы break.

Директива break в строке (*) полностью прекращает выполнение цикла и передаёт управление 
на строку за его телом, то есть на alert.

Вообще, сочетание «бесконечный цикл + break» – отличная штука для тех ситуаций, 
когда условие, по которому нужно прерваться, находится не в начале или конце цикла, а посередине.

Переход к следующей итерации: continue
Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, 
а переходит к следующей итерации (если условие все ещё равно true).
Её используют, если понятно, что на текущем повторе цикла делать больше нечего.
Например, цикл ниже использует continue, чтобы выводить только нечётные значения:

Для чётных значений i, директива continue прекращает выполнение тела цикла и 
передаёт управление на следующую итерацию for (со следующим числом). Таким образом 
alert вызывается только для нечётных значений.

Директива continue позволяет избегать вложенности
Цикл, который обрабатывает только нечётные значения, мог бы выглядеть так:
for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }

}
С технической точки зрения он полностью идентичен. Действительно, 
вместо continue можно просто завернуть действия в блок if.

Однако мы получили дополнительный уровень вложенности фигурных скобок. 
Если код внутри if более длинный, то это ухудшает читаемость, в отличие от 
варианта с continue.

Метки для break/continue
Бывает, нужно выйти одновременно из нескольких уровней цикла сразу.

Например, в коде ниже мы проходимся циклами по i и j, запрашивая с помощью prompt 
координаты (i, j) с (0,0) до (2,2):

for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    // Что если мы захотим перейти к Готово (ниже) прямо отсюда?

  }
}

alert('Готово!');

Нам нужен способ остановить выполнение если пользователь отменит ввод.
Обычный break после input лишь прервёт внутренний цикл, но этого недостаточно. 
Достичь желаемого поведения можно с помощью меток.

labelName: for (...) {
  ...
}




В примере выше это означает, что вызовом break outer будет разорван внешний цикл до
метки с именем outer, и управление перейдёт со строки, помеченной (*), к alert('Готово!').
Можно размещать метку на отдельной строке:

outer:
for (let i = 0; i < 3; i++) { ... }

Директива continue также может быть использована с меткой. 
В этом случае управление перейдёт на следующую итерацию цикла с меткой.

Итого
Мы рассмотрели 3 вида циклов:

while – Проверяет условие перед каждой итерацией.
do..while – Проверяет условие после каждой итерации.
for (;;) – Проверяет условие перед каждой итерацией, есть возможность задать 
дополнительные настройки.
Чтобы организовать бесконечный цикл, используют конструкцию while (true). 
При этом он, как и любой другой цикл, может быть прерван директивой break.

Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать 
цикл не следует – используют директиву continue.

Обе этих директивы поддерживают метки, которые ставятся перед циклом. 
Метки – единственный способ для break/continue выйти за пределы текущего цикла, 
повлиять на выполнение внешнего.

Заметим, что метки не позволяют прыгнуть в произвольное место кода, в JavaScript 
нет такой возможности.







-->












	<script type="text/javascript" src="js/my7.js"> </script>
</body>
</html>
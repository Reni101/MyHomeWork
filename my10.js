'use strict'
/*
//  Function Declaration (Объявление Функции)
function sayHi() {
	alert('Привет');
}

//Function Expression (Функциональное Выражение).

let sayHi = function() {
	alert("Скажи  привет");
}

В коде выше функция создаётся и явно присваивается переменной, как любое другое значение. 
По сути без разницы, как мы определили функцию, это просто значение, хранимое в переменной sayHi.

Смысл обоих примеров кода одинаков: "создать функцию и поместить её значение в переменную sayHi"

function sayHi() {
	alert("Привет");
}
alert( sayHi);
// sayHi ();

Мы можем скопировать функцию в другую переменную:

function sayHi () { //создаём переменную и функцию sayHi
	alert("Hi hi");
}

let func = sayHi // присваиваем func функцию sayHi

//func(); 
 sayHi();
Объявление Function Declaration (1) создало функцию и присвоило её значение переменной с именем 
sayHi.
В строке (2) мы скопировали её значение в переменную func. 
Обратите внимание (ещё раз): нет круглых скобок после sayHi. 
Если бы они были, то выражение func = sayHi() записало бы результат вызова sayHi() 
в переменную func, а не саму функцию sayHi.
Теперь функция может быть вызвана с помощью обеих переменных sayHi() и func()

let sayHi = function(){
	alert('Hi');
};

let func = sayHi;
//тожесамое!

		; 
Нет необходимости в ; в конце блоков кода и синтаксических конструкций, 
которые их используют, таких как if { ... }, for { }, function f { } и т.д.
Function Expression использует внутри себя инструкции присваивания let sayHi = ...; 
как значение. Это не блок кода, а выражение с присваиванием. Таким образом, точка с запятой 
не относится непосредственно к Function Expression, она лишь завершает инструкцию.



Наша функция должна задать вопрос question и, в зависимости от того, 
как ответит пользователь, вызвать yes() или no():

function ask(question, yes, no) {
	if(confirm(question)) yes()
		else no();
}

function showOK() {
	alert("Вы согласны.");
}

function showCancel() {
	alert("Вы отменили выполнение.");
}

ask('Ок или Отмена?',showOK,showCancel);


На практике подобные функции очень полезны. 
Основное отличие «реальной» функции ask от примера выше будет в том, 
что она использует более сложные способы взаимодействия с пользователем, 
чем простой вызов confirm. В браузерах такие функции обычно отображают красивые 
диалоговые окна. Но это уже другая история.

Аргументы функции ask ещё называют функциями-колбэками или просто колбэками.
Ключевая идея в том, что мы передаём функцию и ожидаем, что она вызовется обратно 
когда-нибудь позже, если это будет необходимо. 
В нашем случае, showOk становится колбэком’ для ответа «yes», а showCancel – для ответа «no».
Мы можем переписать этот пример значительно короче, используя Function Expression:



function ask(question, yes, no) {
	if(confirm(question)) yes()
	else no();
}

ask(
	"Ок или Отмена",
	function() {alert("Вы согласны.");},
	function() {alert("Вы отменили выполнение.");}
);

Здесь функции объявляются прямо внутри вызова ask(...). 
У них нет имён, поэтому они называются анонимными. Такие функции недоступны снаружи ask 
(потому что они не присвоены переменным), но это как раз то, что нам нужно.

Функция – это значение, представляющее «действие»
Обычные значения, такие как строки или числа представляют собой данные.

Функции, с другой стороны, можно воспринимать как «действия».

Мы можем передавать их из переменной в переменную и запускать, когда захотим.

Function Expression в сравнении с Function Declaration



// Function Declaration
function sun(a,b){
	return a+b;
}

Function Declaration можно 
использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).

// Function Expression
let sum = function(a,b) {
	return a+ b;
};

Function Expression создаётся, 
когда выполнение доходит до него, и затем уже может использоваться.

sayHi("Максим");
function sayHi(name){
	alert(`Привет, ${name}`);
} // сработает

sayHi("Максим");
let sayHi = function(name) {
	alert(`Привет, ${name}`)
}; // не сработает

В строгом режиме, когда Function Declaration находится в блоке {...}, 
функция доступна везде внутри блока. Но не снаружи него.
Для примера давайте представим, что нам нужно создать функцию welcome() в зависимости от значения переменной age, которое мы получим во время выполнения кода. 
И затем запланируем использовать её когда-нибудь в будущем.
Такой код, использующий Function Declaration, работать не будет:

let age = prompt("Сколько вам лет?", 18)

if(age<18) {
	function welcome(){
		alert("Привет!");
	}
}else {
	function welcome() {
		alert("Здраствуйте");
	}
}

welcome(); // не сработает 

Это произошло, так как объявление Function Declaration 
видимо только внутри блока кода, в котором располагается.
Что можно сделать, чтобы welcome была видима снаружи if?

Верным подходом будет воспользоваться функцией, объявленной при помощи 
Function Expression, и присвоить значение welcome переменной, объявленной снаружи if, 
что обеспечит нам нужную видимость.
*/
let age = prompt("Сколько вам лет", 18)

let welcome;
if (age<18){
	welcome = function(){
		alert("Привет");
	};
} else {
	welcome = function(){
		alert("Здраствуйте");
	};
}

welcome();
